
---
title: "GO 的 GC"
date: 2023-05-03
categories:
- tranquilpeak
- features
tags:
- golang
# keywords:
# - golang
thumbnailImagePosition: left
# thumbnailImage: //d1u9biwaxjngwg.cloudfront.net/elements-showcase/vintage-140.jpg
---

<!--more-->


### GO 的 GC

#### 1:什么是GC

```
Golang从1.5开始引入了三色GC, 经过多次改进, 当前的1.9版本的GC停顿时间已经可以做到极短.
停顿时间的减少意味着"最大响应时间"的缩短, 这也让go更适合编写网络服务程序.

可以看出golang 最近几个版本的变化还是挺大的

先简单介绍一下 golang 1.3之前的标记清除是怎么做的 

---------------------------------------- 1.3 标记清除----------------------------------------

Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：
1 标记
2 清除
第一步，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。
第二步, 开始标记，程序找出它所有可达的对象，并做上标记。
第三步, 标记完了之后，然后开始清除未标记的对象. 
操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。
第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。

标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。
他会出现让程序暂停，程序出现卡顿 标记需要扫描所有的heap,清除数据回产生heap碎片

---------------------------------------- 1.5 三色标记----------------------------------------
golang 在1.5 后的垃圾回收机制 主要应用了三色标记法 ，就是GC过程和其他用户goroutine可并发运行，但需要一定时间的
所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些

1 程序创建时期 ，所有对象都标记为 白色
2 每次GC 回收开始，会从根节点开始遍历所有对象，把遍历到的对象从白色 标记为灰色
3 遍历所有的灰色对象 把灰色对象引用的对象从白色标记为灰色，然后把灰色标记为黑色
4 重复第三步 一直到没有灰色的对象
5 全部执行完毕后 内存中就只有黑和白 其中黑色就是程序用到的对象 白色就是程序用不到的对象 直接作为垃圾数据进行清除
这就是三色标记法

但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。

以为在stw 中 程序回暂时停止任何工作 卡在那一直等待回收执行完毕

---------------------------------------- 1.8 混合写屏障机制----------------------------------------
GO  在1.8之后加入了混合写屏障机制（hybrid write barrier）避免了对栈re-scan的过程，极大的减少了STW的时间。



插入写屏障
当一个对象引用另外一个对象时，将另外一个对象标记为灰色。

插入屏障仅会在堆内存中生效，不对栈内存空间生效，这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护自然会有性能问题。

如果一个栈对象 黑色引用白色对象，白色对象依然会被当作垃圾回收。
因此，最后还需要对栈内存 进行STW，重新rescan，确保所有引用的被引用的栈对象都不会被回收。

删除写屏障
当一个白色对象被另外一个对象时解除引用时，将该被引用对象标记为灰色（白色对象被保护）

缺点：产生内存冗余，如果上述该白色对象没有被别的对象引用，相当于还是垃圾，但是这一轮垃圾回收并没有处理掉他。


那么混合写是如何去做的呢

1:GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2:GC期间，任何在栈上创建的新对象，均为黑色。

3:被删除的对象标记为灰色。

4:被添加的对象标记为灰色。


总结

GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。

GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通

GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。
```

#### 2：GC 调优

```
相关的文档可以查看此文档 https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/

Golang触发GC的一个条件是，内存使用达到上一次GC结束后的一定比例，对于频繁开routine的进程，例如用微服务架构下的服务，很容易频繁触发GC，降低效率。可以通过更改这个默认参数的方式来降低GC次数和时间。

所以在服务中实际使用时，可以大大降低tRPC服务的毛刺数量。目前这个方式有爆内存的风险，可以用一个第三方库 <a href="https://github.com/cch123/gogctuner"> https://github.com/cch123/gogctuner 来帮忙解决GCPercent的问题。


下面介绍一个小例子 

字符串拼接

字符串拼接是很多时候大家会无意间忽略的问题，在以下格式的代码中会出现

func add(a string, b string, c string, d string) string {
   return a + b + c + d
}

在这段代码中，a+b会申请一次内存, a+b+c会申请一次, a+b+c+d又会申请一次，最后频繁的内存申请造成频繁的GC触发，导致代码运行效率低下。
解决办法是使用stringsBuilder来拼接字符串，具体使用方法看strings.Join就能明白。这是一个其他语言中也经常出现的问题

python 字符串拼接也是如此 
一般来说 join 的性能会优于 +  当然在3.6之后 大家目前都会去使用 f'{}' 这种方式去做字符串的拼接。
```



